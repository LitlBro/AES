<div class="box">
    <h2>Algorithme de Key Schedule</h2>
    <p>
		Nous allons nous concentrer ici sur le Key Schedule des clés de 128 bits. Il n'y a qu'une légère altération pour les clés de plus grandes tailles.<br/>
		Les clés faisant 128 bits, cela correspond à 16 octets. Par la suite, ils seront compactés par groupe de 4, tel que :
		<math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="center center center left"><mtr><mtd><mi>S</mi><mi>o</mi><mi>i</mi><mi>t</mi><mo>&#xA0;</mo><mi>K</mi></mtd><mtd><mo>&#x21D4;</mo></mtd><mtd><msub><mi>b</mi><mn>0</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>&#x2026;</mo><msub><mi>b</mi><mn>126</mn></msub><msub><mi>b</mi><mn>127</mn></msub></mtd><mtd><mi>A</mi><mi>v</mi><mi>e</mi><mi>c</mi><mo>&#xA0;</mo><msub><mi>b</mi><mi>i</mi></msub><mo>&#x2208;</mo><mfenced open="{" close="}"><mrow><mn>0</mn><mo>;</mo><mn>1</mn></mrow></mfenced></mtd></mtr><mtr><mtd/><mtd><mo>&#x21D4;</mo></mtd><mtd><msub><mi>V</mi><mn>0</mn></msub><msub><mi>V</mi><mn>1</mn></msub><mo>&#x2026;</mo><msub><mi>V</mi><mn>14</mn></msub><msub><mi>V</mi><mn>15</mn></msub></mtd><mtd><mi>A</mi><mi>v</mi><mi>e</mi><mi>c</mi><mo>&#xA0;</mo><msub><mi>V</mi><mi>i</mi></msub><mo>=</mo><mfenced open="{" close="}"><mrow><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>4</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>5</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>6</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>b</mi><mrow><mn>8</mn><mi>i</mi><mo>+</mo><mn>7</mn></mrow></msub><mo>&#xA0;</mo></mrow></mfenced></mtd></mtr><mtr><mtd/><mtd><mo>&#x21D4;</mo></mtd><mtd><msub><mi>W</mi><mn>0</mn></msub><msub><mi>W</mi><mn>1</mn></msub><msub><mi>W</mi><mn>2</mn></msub><msub><mi>W</mi><mn>3</mn></msub></mtd><mtd><mi>A</mi><mi>v</mi><mi>e</mi><mi>c</mi><mo>&#xA0;</mo><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><mo>{</mo><msub><mi>V</mi><mrow><mn>4</mn><mi>i</mi></mrow></msub><mo>&#xA0;</mo><msub><mi>V</mi><mrow><mn>4</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>V</mi><mrow><mn>4</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&#xA0;</mo><msub><mi>V</mi><mrow><mn>4</mn><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>}</mo></mtd></mtr></mtable></math><br/>
		Dans le cas d'une clé de 128 bits, il y a 10 répétitions de l'algorithme. Il faut donc générer 10 clés supplémentaires (une clé étant utilisée avant le début des répétitions).<br/>
		Le Key schedule se répète à chaque nouvelle clé. Ainsi la i<sup>éme</sup> clé est calculée à partir de la clé i+1.<br/>
		on a  : <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mi>e</mi><mi>y</mi><mi>S</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>l</mi><mi>e</mi><mo>(</mo><msub><mi>K</mi><mi>i</mi></msub><mo>)</mo><mo>=</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math><br/>
	</p>
	<p>
		L'opération d'extension de la clé consiste donc à produire 128 bits. On a ainsi le format suivant : <br/>
		<math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced open="{" close=""><mtable columnalign="center left center"><mtr><mtd><msub><mi>W</mi><mn>4</mn></msub><mo>=</mo></mtd><mtd><msub><mi>W</mi><mn>0</mn></msub><mo>+</mo><mi>g</mi><mo>(</mo><msub><mi>W</mi><mn>3</mn></msub><mo>)</mo></mtd><mtd><mi>A</mi><mi>v</mi><mi>e</mi><mi>c</mi><mo>&#xA0;</mo><mi>g</mi><mo>(</mo><mo>)</mo><mo>&#xA0;</mo><mi>f</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>&#xA0;</mo><mi>n</mi><mi>o</mi><mi>n</mi><mo>&#xA0;</mo><mi>l</mi><mi>i</mi><mi>n</mi><mi>&#xE9;</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>e</mi></mtd></mtr><mtr><mtd><msub><mi>W</mi><mn>5</mn></msub><mo>=</mo></mtd><mtd><msub><mi>W</mi><mn>4</mn></msub><mo>+</mo><msub><mi>W</mi><mn>1</mn></msub></mtd><mtd/></mtr><mtr><mtd><msub><mi>W</mi><mn>6</mn></msub><mo>=</mo></mtd><mtd><msub><mi>W</mi><mn>5</mn></msub><mo>+</mo><msub><mi>W</mi><mn>2</mn></msub></mtd><mtd/></mtr><mtr><mtd><msub><mi>W</mi><mn>7</mn></msub><mo>=</mo></mtd><mtd><msub><mi>W</mi><mn>6</mn></msub><mo>+</mo><msub><mi>W</mi><mn>3</mn></msub></mtd><mtd/></mtr></mtable></mfenced></math><br/>
	</p>
    <p>
		Le système ici est assez simple et se répétera à chaque itération de Key Schedule. (Pour la répétition suivante, W4 devient W0 et ainsi de de suite).<br/>
		La somme se fait selon le schéma habituel, il s'agit d'une opération XOR (bit à bit) sur les deux blocs de 128 bits (somme dans GF(2)).<br/>
		Le point important ici est la fonction g(). Elle s'applique donc sur un bloc de 4 octets et se décompose en 3 étapes <br/>
		ici 
			<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub><mo>,</mo><msub><mi>g</mi><mn>3</mn></msub></math>
		représente les 3 étapes de la fonction g() : 
    </p>
    <ol>
		<li>
			un décalage (similaire à un ShiftColumn) de 3 :<br/>
			<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><msub><mi>W</mi><mn>3</mn></msub><mo>)</mo><mo>=</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><msub><mi>V</mi><mn>12</mn></msub><msub><mi>V</mi><mn>13</mn></msub><msub><mi>V</mi><mn>14</mn></msub><msub><mi>V</mi><mn>15</mn></msub><mo>)</mo><mo>=</mo><msub><mi>V</mi><mn>13</mn></msub><msub><mi>V</mi><mn>14</mn></msub><msub><mi>V</mi><mn>15</mn></msub><msub><mi>V</mi><mn>12</mn></msub></math><br/>
		</li>
		<br/>
		<li>
			On applique ensuite à chaque octet la transformation SubByte : <br/>
			<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><msub><mi>V</mi><mn>13</mn></msub><msub><mi>V</mi><mn>14</mn></msub><msub><mi>V</mi><mn>15</mn></msub><msub><mi>V</mi><mn>12</mn></msub><mo>)</mo><mo>=</mo><mi>S</mi><mo>(</mo><msub><mi>V</mi><mn>13</mn></msub><mo>)</mo><mi>S</mi><mo>(</mo><msub><mi>V</mi><mn>14</mn></msub><mo>)</mo><mi>S</mi><mo>(</mo><msub><mi>V</mi><mn>15</mn></msub><mo>)</mo><mi>S</mi><mo>(</mo><msub><mi>V</mi><mn>12</mn></msub><mo>)</mo><mo>=</mo><msubsup><mi>V</mi><mn>13</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>14</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>15</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>12</mn><mo>'</mo></msubsup></math><br/>
		</li>
		<br/>
		<li>
			On somme sur le premier octet un coefficient (puissance de 2 dans GF(2<sup>8</sup>) qui va dépendre de l'indice j de la répétition.<br/>
			<math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="right left"><mtr><mtd><msub><mi>g</mi><mn>3</mn></msub><mo>(</mo><msubsup><mi>V</mi><mn>13</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>14</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>15</mn><mo>'</mo></msubsup><msubsup><mi>V</mi><mn>12</mn><mo>'</mo></msubsup><mo>)</mo><mo>=</mo></mtd><mtd><msubsup><mi>V</mi><mn>13</mn><mo>'</mo></msubsup><mo>+</mo><msup><mi>R</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>&#xA0;</mo><msubsup><mi>V</mi><mn>14</mn><mo>'</mo></msubsup><mo>&#xA0;</mo><msubsup><mi>V</mi><mn>15</mn><mo>'</mo></msubsup><mo>&#xA0;</mo><msubsup><mi>V</mi><mn>12</mn><mo>'</mo></msubsup></mtd></mtr><mtr><mtd><mi>A</mi><mi>v</mi><mi>e</mi><mi>c</mi><mo>&#xA0;</mo><mi>R</mi><mo>=</mo></mtd><mtd><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>7</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>6</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>5</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>4</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>3</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>*</mo><msup><mi>X</mi><mn>1</mn></msup><mo>+</mo><mn>0</mn><mo>*</mo><msup><mi>X</mi><mn>0</mn></msup></mtd></mtr></mtable></math><br/>
		</li>
    </ol>
    
    <p>
		Comme nous sommes toujours dans GF(2<sup>8</sup>), les puissances de ce polynôme sont restreintes par le polynôme caractéristique de l'AES, P (voir section Maths).<br/>
		Ainsi on a  : <br/>
		<div><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo>&#xA0;</mo><mi>d</mi><mi>e</mi><mo>&#xA0;</mo><mi>l</mi><mi>a</mi><mo>&#xA0;</mo><mi>r</mi><mi>&#xE9;</mi><mi>p</mi><mi>&#xE9;</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mtd><mtd><mi>j</mi><mo>=</mo><mn>1</mn><mo>;</mo><mo>&#xA0;</mo></mtd><mtd><msup><mi>R</mi><mn>0</mn></msup><mo>&#xA0;</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>&#xA0;</mo><mi>P</mi><mo>=</mo></mtd><mtd><mo>(</mo><mn>00000001</mn><msub><mo>)</mo><mn>2</mn></msub></mtd></mtr><mtr><mtd/><mtd><mi>j</mi><mo>=</mo><mn>2</mn><mo>;</mo><mo>&#xA0;</mo></mtd><mtd><msup><mi>R</mi><mn>1</mn></msup><mo>&#xA0;</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>&#xA0;</mo><mi>P</mi><mo>=</mo></mtd><mtd><mo>(</mo><mn>00000010</mn><msub><mo>)</mo><mn>2</mn></msub></mtd></mtr><mtr><mtd/><mtd><mi>j</mi><mo>=</mo><mn>3</mn><mo>;</mo><mo>&#xA0;</mo></mtd><mtd><msup><mi>R</mi><mn>2</mn></msup><mo>&#xA0;</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>&#xA0;</mo><mi>P</mi><mo>=</mo></mtd><mtd><mo>(</mo><mn>00000100</mn><msub><mo>)</mo><mn>2</mn></msub></mtd></mtr><mtr><mtd/><mtd><mo>&#x22EE;</mo></mtd><mtd><mo>&#x22EE;</mo></mtd><mtd><mo>&#x22EE;</mo></mtd></mtr><mtr><mtd/><mtd><mi>j</mi><mo>=</mo><mn>4</mn><mo>;</mo><mo>&#xA0;</mo></mtd><mtd><msup><mi>R</mi><mn>9</mn></msup><mo>&#xA0;</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>&#xA0;</mo><mi>P</mi><mo>=</mo></mtd><mtd><mo>(</mo><mn>00110110</mn><msub><mo>)</mo><mn>2</mn></msub></mtd></mtr></mtable></math></div><br/>
    </p>
    <br/>
    <p>
		Pour résumer on a donc les 128 bits qui sont réunis par groupe de 4 octets, le premier est sommé avec le troisième, modifié par g().<br/>
		Tout les autres sont ensuite sommés avec l'élément précédent et l'élément équivalent dans la clé précédente.<br/>
		Cela donne le schéma suivant : 
		<image src="/tx/public/image/round_key.jpg " class="img-responsive" alt="algorithm"> <br/>
 
    </p>
    <br/>
    
    <h2>Clés de 192 bits</h2>
    <p>
		le schéma pour la création des sous-clés de 192 bits est presque similaire : <br/>
		<image src="/tx/public/image/key_schedule_192.jpg " class="img-responsive" alt="algorithm"> <br/>
		Il y a cependant un élément à prendre en compte, il y a besoin d'aller jusqu'a 
			<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>51</mn></msub></math>.
			Or, on créé a chaque fois 6 nouveaux éléments 
			<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><msub><mi>W</mi><mn>5</mn></msub><mo>&#x2192;</mo><msub><mi>W</mi><mn>11</mn></msub><mo>)</mo></math>.<br/>
		On arrive donc à 
		<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>47</mn></msub></math>, il ne faut donc que 4 élements supplémentaires 
		<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><msub><mi>W</mi><mn>48</mn></msub><mo>&#x2192;</mo><msub><mi>W</mi><mn>51</mn></msub><mo>)</mo></math>.<br/>
		Pour la fonction g(), il s'agit toujours du dernier élement de la ligne précédente (le 6<sup>ème</sup> parmis 6).<br/>
		(Il serait possible de créer encore 6 éléments, mais 2 ne seraient jamais utilisés.)<br/>			
    </p>
    
    <h2> Clés de 256 bits</h2>
    <p>
		le schéma pour la création des sous-clés de 256 bits est presque similaire : <br/>
		<image src="/tx/public/image/key_schedule_256.jpg " class="img-responsive" alt="algorithm"> <br/>
		De même que pour les clés de 192 bits, lors de la dernière itération il n'est nécessaire de créer que 4 éléments 
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><msub><mi>W</mi><mn>56</mn></msub><mo>&#x2192;</mo><msub><mi>W</mi><mn>59</mn></msub><mo>)</mo></math>.<br/>
		On peut voir un ajout ici, il s'agit de la deuxième étape de la fonction g(), l'opération SubByte.<br/>

    </p>
</div>
